### 235.[Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/#/description)
>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”
```
        _______6______
       /              \
    ___2__          ___8__
   /      \        /      \
   0      _4       7       9
         /  \
         3   5
```
>For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
----
### Java
```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(p.val < root.val && q.val < root.val){
            return lowestCommonAncestor(root.left,p,q);
        }else if(p.val > root.val && q.val > root.val){
            return lowestCommonAncestor(root.right,p,q);}
        else
        return root;
    }
}
/*
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        while(true){
          if((root.val-p.val)*(root.val-q.val)<=0) return root;
          if(p.val<root.val){
             root=root.left;
          }
         else{
              root=root.right;
          }
        }
    }
}

If the given both nodes values are less than that of root, then both the nodes must be on the left side of the root , so now we have to check only left tree of the root.
Otherwise If the given both nodes values are greater than that of root, then both the nodes must be on the right side of the root , so now we have to check only right tree of the root.
Otherwise . both the nodes will be on the either side of the root, this implies the lowest common ancestor is root.
*/
```
### 104.[ Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/#/description)
>Given a binary tree, find its maximum depth.  

>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.  
----
### Java
```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null){
            return 0;
        }
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
    }
}

/*  
//my: is not right, because without memory of root.right and root.left, cannnot loop down
public int maxDepth(TreeNode root) {
        int depth=1;//depth is the 1+the longer distance of its subtree.
        while(true){
            root=root.left;
            root=root.right;
            depth++;
}
// iteration method
public int maxDepth(TreeNode root) {
    int max = 0;
    if (root == null) {return 0;}
    Stack<TreeNode> path = new Stack<>();
    Stack<Integer> sub = new Stack<>();
    path.push(root);
    sub.push(1);
    while (!path.isEmpty()) {
        TreeNode temp = path.pop();
        int tempVal = sub.pop();
        if (temp.left == null && temp.right == null) {max = Math.max(max, tempVal);}
        else {
            if (temp.left != null) {
                path.push(temp.left);
                sub.push(tempVal + 1);
            }
            if (temp.right != null) {
                path.push(temp.right);
                sub.push(tempVal + 1);
            }
        }
    }
    return max;
}
        
    }*/
```
